# 查询处理

## Summary
SQL引擎的核心功能为查询处理，其主要结构如下：

![image-20250216164113812](https://raw.githubusercontent.com/Teletele-Lin/cos/main/picgo/image-20250216164113812.png)

+ Parser  
  解析器的主要功能是将原始的SQL文本转化为解析树（Parser Tree），作为分析器的标准输入。只会返回SQL文本中的语法错误，不会返回语义的错误。
+ Analyzer  
  解析树的本质是一个抽象的语法树，不能够被数据库的优化器直接使用，因此引入分析器，将解析树转换为一个查询树。查询树的本质是为优化器提供一个规范化输入的一个结构。这个过程中也会检查语义上的错误。
+ Rewriter  
  解析和重写的输出都是一个查询树，因此在PG中使用函数`pg_analyze_and_rewrite`直接返回一个查询树。在重写这个过程中，主要在逻辑上实现对SQL查询的等价重构和优化。重构体现在视图的展开、基于规则系统的重写等；优化体现在将子查询转换为连接操作等场景。
+ Planner  
  优化器的功能是根据查询树，计算最优的执行路径，并返回一个计划树给执行器执行。它是基于代价评估计算拿到最优的执行路径。
+ Executor  
  执行器的功能是根据计划树，在不同的算子中，调用存储的接口来查询或修改数据。Plan Tree是一个树状的结构，不同的节点类型对应不同的算子，上层算子调用下层算子的get_next接口，拿到下层算子返回的tuple；下层算子的get_next接口被上层算子调用时，向上层返回tuple（一行数据一般对应一条tuple），这个流程是标准的火山模型，get_next的调用是从上到下，结果的返回是从下到上。

## SQL执行流程

`exec_simple_query`最常用的SQL执行的入口函数。

```c
/*
 * exec_simple_query
 *
 * Execute a "simple Query" protocol message.
 */
static void
exec_simple_query(const char *query_string)
{
    ···    
	/*
	 * Start up a transaction command.  All queries generated by the
	 * query_string will be in this same command block, *unless* we find a
	 * BEGIN/COMMIT/ABORT statement; we have to force a new xact command after
	 * one of those, else bad things will happen in xact.c. (Note that this
	 * will normally change current memory context.)
	 */
	start_xact_command(); // 开启一个循环外的事务
    ···  
    /*
	 * Switch to appropriate context for constructing parsetrees.
	 */
	oldcontext = MemoryContextSwitchTo(MessageContext); // 做语法解析之前，切换到MessageContext内存上下文
    
    /*
	 * Do basic parsing of the query or queries (this should be safe even if
	 * we are in aborted transaction state!)
	 */
	parsetree_list = pg_parse_query(query_string); // 执行语法解析
    
    /*
	 * Switch back to transaction context to enter the loop.
	 */
	MemoryContextSwitchTo(oldcontext); // 切换回内存上下文
     
    /*
	 * Run through the raw parsetree(s) and process each one.
	 */
	foreach(parsetree_item, parsetree_list) // 遍历解析树，一个解析树的item是一个查询
    {
		···
		/* Make sure we are in a transaction command */            
       	start_xact_command(); // 开启循环内事务
         
        // 为parsertree_item切换到合适的内存上下文
        if (lnext(parsetree_list, parsetree_item) != NULL)
		{
			per_parsetree_context =
				AllocSetContextCreate(MessageContext,
									  "per-parsetree message context",
									  ALLOCSET_DEFAULT_SIZES);
			oldcontext = MemoryContextSwitchTo(per_parsetree_context);
		}
		else
			oldcontext = MemoryContextSwitchTo(MessageContext);
		
        // 执行查询解析和重新，返回querytree_list
		querytree_list = pg_analyze_and_rewrite_fixedparams(parsetree, query_string,
															NULL, 0, NULL);
		
        // 执行查询优化，返回plantree_list
		plantree_list = pg_plan_queries(querytree_list, query_string,
										CURSOR_OPT_PARALLEL_OK, NULL);
          
    /*
		 * Create unnamed portal to run the query or queries in. If there
		 * already is one, silently drop it.
		 */
		portal = CreatePortal("", true, true);  // 创建一个portal，一个portal中包含执行器所需要的所有信息
		/* Don't display the portal in pg_cursors */
		portal->visible = false;

		/*
		 * We don't have to copy anything into the portal, because everything
		 * we are passing here is in MessageContext or the
		 * per_parsetree_context, and so will outlive the portal anyway.
		 */
		PortalDefineQuery(portal,
						  NULL,
						  query_string,
						  commandTag,
						  plantree_list,
						  NULL); // 对portol进行初始化

		/*
		 * Start the portal.  No parameters here.
		 */
        // portal运行前的准备，选择执行策略，对portal元数据进行更新，调用ExecutorStart完成执行器的准备工作
		PortalStart(portal, NULL, 0, InvalidSnapshot);
        
        /*
		 * Now we can create the destination receiver object.
		 */
		receiver = CreateDestReceiver(dest);
		if (dest == DestRemote)
			SetRemoteDestReceiverParams(receiver, portal); // SQL执行结果的接收器，如果有returning语法，将会返回受影响的行

		/*
		 * Switch back to transaction context for execution.
		 */
		MemoryContextSwitchTo(oldcontext); // 切换回内存上下文
        
    	/*
		 * Run the portal to completion, and then drop it (and the receiver).
		 */
        // 执行Portal中的查询，调用执行器ExecutorRun
		(void) PortalRun(portal,
						 FETCH_ALL,
						 true,	/* always top level */
						 receiver,
						 receiver,
						 &qc);
        // 对Portal进行清理，
        PortalDrop(portal, false);
        
        // 循环内的事务结束
        finish_xact_command();
        
		···  
    }
    ···
    // 循环外结束事务
	finish_xact_command(); 
    ···  
}
```

